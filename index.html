<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Spatial Transcriptomics Viewer</title>
<script src="https://unpkg.com/deck.gl@9.0.16/dist.min.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a2e; color: #e0e0e0; display: flex; height: 100vh; overflow: hidden; }

/* Sidebar */
#sidebar {
  width: 300px; min-width: 300px; background: #16213e; display: flex; flex-direction: column;
  border-right: 1px solid #0f3460; overflow: hidden; z-index: 10;
}
#sidebar-header { padding: 16px; border-bottom: 1px solid #0f3460; }
#sidebar-header h1 { font-size: 16px; color: #e94560; margin-bottom: 4px; }
#sidebar-header .stats { font-size: 12px; color: #888; }
#sidebar-content { flex: 1; overflow-y: auto; padding: 12px; }

/* Mode toggle */
.mode-toggle { display: flex; gap: 0; margin-bottom: 12px; }
.mode-btn {
  flex: 1; padding: 8px; text-align: center; cursor: pointer; font-size: 13px; font-weight: 600;
  background: #1a1a2e; border: 1px solid #0f3460; color: #888; transition: all 0.2s;
}
.mode-btn:first-child { border-radius: 6px 0 0 6px; }
.mode-btn:last-child { border-radius: 0 6px 6px 0; }
.mode-btn.active { background: #0f3460; color: #e94560; border-color: #e94560; }

/* Sections */
.section { margin-bottom: 16px; }
.section-title { font-size: 12px; font-weight: 600; text-transform: uppercase; color: #888; margin-bottom: 8px; letter-spacing: 0.5px; }

/* Cell type list */
#celltype-list { max-height: calc(100vh - 440px); overflow-y: auto; }
.ct-row {
  display: flex; align-items: center; gap: 6px; padding: 3px 4px; border-radius: 4px; cursor: pointer; font-size: 13px;
}
.ct-row:hover { background: rgba(255,255,255,0.05); }
.ct-row input[type="checkbox"] { cursor: pointer; flex-shrink: 0; }
.ct-row input[type="color"] {
  width: 22px; height: 22px; border: none; cursor: pointer; background: none; padding: 0; flex-shrink: 0;
  border-radius: 3px;
}
.ct-row input[type="color"]::-webkit-color-swatch-wrapper { padding: 1px; }
.ct-row input[type="color"]::-webkit-color-swatch { border: 1px solid #555; border-radius: 2px; }
.ct-label { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; user-select: none; }
.ct-count { font-size: 11px; color: #666; flex-shrink: 0; }

/* Bulk actions */
.bulk-actions { display: flex; gap: 8px; margin-bottom: 8px; }
.bulk-btn {
  font-size: 11px; color: #e94560; cursor: pointer; background: none; border: none; text-decoration: underline;
}

/* Gene search */
#gene-section { display: none; }
#gene-search {
  width: 100%; padding: 8px 10px; background: #1a1a2e; border: 1px solid #0f3460; border-radius: 6px;
  color: #e0e0e0; font-size: 13px; outline: none;
}
#gene-search:focus { border-color: #e94560; }
#gene-dropdown {
  max-height: 200px; overflow-y: auto; background: #1a1a2e; border: 1px solid #0f3460; border-radius: 0 0 6px 6px;
  display: none; margin-top: -1px;
}
.gene-option {
  padding: 6px 10px; cursor: pointer; font-size: 13px;
}
.gene-option:hover, .gene-option.highlighted { background: #0f3460; }
#current-gene { margin-top: 8px; font-size: 13px; }
#clear-gene-btn {
  font-size: 11px; color: #e94560; cursor: pointer; background: none; border: none;
  text-decoration: underline; margin-left: 8px;
}

/* Color scale legend for expression */
#expression-legend { display: none; margin-top: 12px; }
#legend-gradient {
  width: 100%; height: 14px; border-radius: 3px;
  background: linear-gradient(to right, #440154, #482777, #3e4989, #31688e, #26828e, #1f9e89, #35b779, #6ece58, #b5de2b, #fde725);
}
#legend-labels { display: flex; justify-content: space-between; font-size: 11px; color: #888; margin-top: 2px; }

/* Bottom buttons */
#sidebar-footer { padding: 12px; border-top: 1px solid #0f3460; display: flex; gap: 8px; flex-wrap: wrap; }
.action-btn {
  flex: 1; padding: 8px; text-align: center; background: #0f3460; border: 1px solid #0f3460;
  border-radius: 6px; color: #e0e0e0; cursor: pointer; font-size: 12px; transition: background 0.2s;
  min-width: 80px;
}
.action-btn:hover { background: #e94560; }

/* Tooltip */
#tooltip {
  position: fixed; pointer-events: none; background: rgba(22,33,62,0.95); border: 1px solid #0f3460;
  border-radius: 6px; padding: 8px 12px; font-size: 12px; z-index: 100; display: none;
  max-width: 280px; box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}
#tooltip .tt-label { color: #888; font-size: 11px; }
#tooltip .tt-value { color: #e0e0e0; margin-bottom: 4px; }

/* Loading overlay */
#loading {
  position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(26,26,46,0.95);
  display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000;
}
#loading .spinner { width: 40px; height: 40px; border: 3px solid #0f3460; border-top-color: #e94560; border-radius: 50%; animation: spin 0.8s linear infinite; }
@keyframes spin { to { transform: rotate(360deg); } }
#loading-text { margin-top: 16px; color: #888; font-size: 14px; }

/* Canvas container */
#deck-container { flex: 1; position: relative; }
#deck-canvas { width: 100%; height: 100%; }

/* Mobile responsive */
@media (max-width: 768px) {
  #sidebar { position: fixed; left: -300px; transition: left 0.3s; height: 100vh; z-index: 20; }
  #sidebar.open { left: 0; }
  #menu-toggle {
    position: fixed; top: 12px; left: 12px; z-index: 15; background: #16213e; border: 1px solid #0f3460;
    color: #e0e0e0; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 18px; display: block;
  }
}
@media (min-width: 769px) { #menu-toggle { display: none; } }

/* Slider rows */
.slider-row { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
.slider-row label { font-size: 12px; color: #888; white-space: nowrap; }
.slider-row input[type="range"] { flex: 1; }
.slider-row .slider-val { font-size: 12px; color: #e0e0e0; min-width: 20px; text-align: right; }

/* Render mode toggle */
.render-toggle { display: flex; align-items: center; gap: 8px; margin-bottom: 12px; }
.render-toggle label { font-size: 12px; color: #888; }
.toggle-switch {
  position: relative; width: 44px; height: 22px; background: #1a1a2e; border: 1px solid #0f3460;
  border-radius: 11px; cursor: pointer; transition: background 0.2s;
}
.toggle-switch.active { background: #0f3460; border-color: #e94560; }
.toggle-switch .toggle-knob {
  position: absolute; top: 2px; left: 2px; width: 16px; height: 16px; background: #888;
  border-radius: 50%; transition: all 0.2s;
}
.toggle-switch.active .toggle-knob { left: 24px; background: #e94560; }
.toggle-label { font-size: 12px; color: #e0e0e0; }
</style>
</head>
<body>

<button id="menu-toggle" onclick="document.getElementById('sidebar').classList.toggle('open')">&#9776;</button>

<div id="sidebar">
  <div id="sidebar-header">
    <h1 id="dataset-name">Loading...</h1>
    <div class="stats" id="dataset-stats"></div>
  </div>
  <div id="sidebar-content">
    <!-- Mode toggle -->
    <div class="mode-toggle">
      <div class="mode-btn active" id="mode-celltype" onclick="setMode('celltype')">Cell Type</div>
      <div class="mode-btn" id="mode-expression" onclick="setMode('expression')">Expression</div>
    </div>

    <!-- Render mode: Points vs Polygons -->
    <div class="render-toggle" id="render-toggle-row">
      <label>Render:</label>
      <span class="toggle-label">Points</span>
      <div class="toggle-switch" id="poly-toggle" onclick="toggleRenderMode()">
        <div class="toggle-knob"></div>
      </div>
      <span class="toggle-label">Polygons</span>
    </div>

    <!-- Point size slider (only in point mode) -->
    <div class="slider-row" id="point-size-row">
      <label>Point size</label>
      <input type="range" id="point-size-slider" min="1" max="20" value="4" oninput="setPointSize(this.value)">
      <span class="slider-val" id="point-size-val">4</span>
    </div>

    <!-- Polygon outline slider (only in polygon mode) -->
    <div class="slider-row" id="poly-outline-row" style="display:none;">
      <label>Outline</label>
      <input type="range" id="poly-outline-slider" min="0" max="3" value="0.5" step="0.1" oninput="setPolyOutline(this.value)">
      <span class="slider-val" id="poly-outline-val">0.5</span>
    </div>

    <!-- Cell type section -->
    <div id="celltype-section">
      <div class="section">
        <div class="section-title">Cell Types</div>
        <div class="bulk-actions">
          <button class="bulk-btn" onclick="toggleAll(true)">Select All</button>
          <button class="bulk-btn" onclick="toggleAll(false)">Deselect All</button>
        </div>
        <div id="celltype-list"></div>
      </div>
    </div>

    <!-- Gene expression section -->
    <div id="gene-section">
      <div class="section">
        <div class="section-title">Gene Expression</div>
        <input type="text" id="gene-search" placeholder="Search genes..." autocomplete="off">
        <div id="gene-dropdown"></div>
        <div id="current-gene"></div>
        <div id="expression-legend">
          <div id="legend-gradient"></div>
          <div id="legend-labels"><span id="legend-min">0</span><span>Expression</span><span id="legend-max">1</span></div>
        </div>
      </div>

      <!-- Cell types still shown in expression mode for reference -->
      <div class="section" style="margin-top: 12px;">
        <div class="section-title">Visible Cell Types</div>
        <div class="bulk-actions">
          <button class="bulk-btn" onclick="toggleAll(true)">Select All</button>
          <button class="bulk-btn" onclick="toggleAll(false)">Deselect All</button>
        </div>
        <div id="celltype-list-expr"></div>
      </div>
    </div>
  </div>
  <div id="sidebar-footer">
    <button class="action-btn" onclick="resetView()">Reset View</button>
    <button class="action-btn" onclick="takeScreenshot()">Screenshot</button>
  </div>
</div>

<div id="deck-container">
  <div id="deck-canvas"></div>
</div>

<div id="tooltip"></div>

<div id="loading">
  <div class="spinner"></div>
  <div id="loading-text">Loading spatial data...</div>
</div>

<script>
// ============================================================================
// Global State
// ============================================================================
let cellData = null;       // {x:[], y:[], celltype:[], cell_id:[]}
let metadata = null;       // {dataset_name, n_cells, cell_types, bounds, ...}
let geneList = null;       // {geneName: filename, ...}
let currentMode = 'celltype';
let currentGene = null;
let currentGeneExpr = null;
let celltypeVisible = {};  // {typeName: bool}
let celltypeColors = {};   // {typeName: [r,g,b]}
let deckgl = null;
let pointRadius = 4;
let polyOutlineWidth = 0.5;
let renderMode = 'points'; // 'points' or 'polygons'

// Pre-built typed arrays for performance
let positions = null;      // Float64Array(N*3)
let colors = null;         // Uint8Array(N*4)

// Polygon data (binary)
let polyCoords = null;     // Float32Array — interleaved [x0,y0,x1,y1,...]
let polyOffsets = null;     // Uint32Array — start index per cell (N+1 entries)
let hasPolygons = false;

// Per-cell polygon arrays for deck.gl (built once)
let polygonData = null;    // Array of {polygon: [[x,y],...], index: i}

// ============================================================================
// Default 28-color palette (distinguishable)
// ============================================================================
const DEFAULT_PALETTE = [
  [230, 25, 75],   [60, 180, 75],   [255, 225, 25],  [0, 130, 200],
  [245, 130, 48],  [145, 30, 180],  [70, 240, 240],  [240, 50, 230],
  [210, 245, 60],  [250, 190, 212], [0, 128, 128],   [220, 190, 255],
  [170, 110, 40],  [255, 250, 200], [128, 0, 0],     [170, 255, 195],
  [128, 128, 0],   [255, 215, 180], [0, 0, 128],     [128, 128, 128],
  [230, 190, 255], [255, 127, 80],  [100, 149, 237], [144, 238, 144],
  [255, 182, 193], [218, 165, 32],  [72, 209, 204],  [255, 99, 71],
  [147, 112, 219], [60, 179, 113],  [255, 165, 0],   [106, 90, 205]
];

// Viridis colormap (10 stops for interpolation)
const VIRIDIS = [
  [68, 1, 84], [72, 39, 119], [62, 73, 137], [49, 104, 142],
  [38, 130, 142], [31, 158, 137], [53, 183, 121], [110, 206, 88],
  [181, 222, 43], [253, 231, 37]
];

// ============================================================================
// Initialization
// ============================================================================
async function init() {
  setLoadingText('Loading cell positions...');
  const cellsResp = await fetch('data/cells.json');
  cellData = await cellsResp.json();

  setLoadingText('Loading metadata...');
  const metaResp = await fetch('data/metadata.json');
  metadata = await metaResp.json();

  setLoadingText('Loading gene list...');
  const geneResp = await fetch('data/gene_list.json');
  geneList = await geneResp.json();

  // Update UI header
  document.getElementById('dataset-name').textContent = metadata.dataset_name;
  document.getElementById('dataset-stats').textContent =
    `${metadata.n_cells.toLocaleString()} cells · ${metadata.n_celltypes} types · ${metadata.n_genes} genes`;

  // Initialize colors and visibility from localStorage or defaults
  loadColorPreferences();

  // Build typed arrays for point rendering
  setLoadingText('Building render buffers...');
  await buildArrays();

  // Load polygon data if available
  if (metadata.has_polygons) {
    setLoadingText('Loading polygon shapes...');
    try {
      const [coordsBuf, offsetsBuf] = await Promise.all([
        fetch('data/poly_coords.bin').then(r => r.arrayBuffer()),
        fetch('data/poly_offsets.bin').then(r => r.arrayBuffer())
      ]);
      polyCoords = new Float32Array(coordsBuf);
      polyOffsets = new Uint32Array(offsetsBuf);
      hasPolygons = true;

      setLoadingText('Building polygon geometry...');
      buildPolygonData();
    } catch (e) {
      console.warn('Polygon data not available:', e);
      hasPolygons = false;
    }
  }

  // Show/hide polygon toggle
  if (!hasPolygons) {
    document.getElementById('render-toggle-row').style.display = 'none';
  }

  // Build UI
  buildCelltypeUI();
  buildGeneSearch();

  // Initialize deck.gl
  setLoadingText('Initializing renderer...');
  initDeck();

  // Check URL hash for shared state
  restoreFromHash();

  // Hide loading
  document.getElementById('loading').style.display = 'none';
}

function setLoadingText(text) {
  document.getElementById('loading-text').textContent = text;
}

// ============================================================================
// Color Preferences (localStorage)
// ============================================================================
function loadColorPreferences() {
  const saved = localStorage.getItem('spatial_viewer_colors');
  const savedObj = saved ? JSON.parse(saved) : {};

  metadata.cell_types.forEach((ct, i) => {
    if (savedObj[ct]) {
      celltypeColors[ct] = savedObj[ct];
    } else {
      celltypeColors[ct] = DEFAULT_PALETTE[i % DEFAULT_PALETTE.length];
    }
    celltypeVisible[ct] = true;
  });
}

function saveColorPreferences() {
  localStorage.setItem('spatial_viewer_colors', JSON.stringify(celltypeColors));
}

// ============================================================================
// Build Typed Arrays (for point rendering)
// ============================================================================
async function buildArrays() {
  const N = cellData.x.length;
  positions = new Float64Array(N * 3);
  colors = new Uint8Array(N * 4);

  for (let i = 0; i < N; i++) {
    positions[i * 3]     = cellData.x[i];
    positions[i * 3 + 1] = cellData.y[i];
    positions[i * 3 + 2] = 0;
  }

  rebuildColors();
}

// ============================================================================
// Build Polygon Data (for polygon rendering)
// ============================================================================
function buildPolygonData() {
  const N = cellData.x.length;
  polygonData = new Array(N);

  for (let i = 0; i < N; i++) {
    const startVert = polyOffsets[i];
    const endVert = polyOffsets[i + 1];
    const nVerts = endVert - startVert;

    if (nVerts > 0) {
      const ring = new Array(nVerts);
      for (let v = 0; v < nVerts; v++) {
        const ci = (startVert + v) * 2;
        ring[v] = [polyCoords[ci], polyCoords[ci + 1]];
      }
      polygonData[i] = { polygon: ring, index: i };
    } else {
      polygonData[i] = { polygon: [[0,0],[0,0],[0,0]], index: i };
    }
  }
}

function rebuildColors() {
  const N = cellData.x.length;

  if (currentMode === 'celltype') {
    for (let i = 0; i < N; i++) {
      const ct = cellData.celltype[i];
      const rgb = celltypeColors[ct] || [128, 128, 128];
      const visible = celltypeVisible[ct] !== false;
      colors[i * 4]     = rgb[0];
      colors[i * 4 + 1] = rgb[1];
      colors[i * 4 + 2] = rgb[2];
      colors[i * 4 + 3] = visible ? 220 : 0;
    }
  } else if (currentMode === 'expression' && currentGeneExpr) {
    const expr = currentGeneExpr;
    const maxVal = expr.maxVal || 1;
    for (let i = 0; i < N; i++) {
      const ct = cellData.celltype[i];
      const visible = celltypeVisible[ct] !== false;
      const val = expr.dense[i];
      if (!visible) {
        colors[i * 4 + 3] = 0;
        continue;
      }
      if (val === 0) {
        colors[i * 4]     = 30;
        colors[i * 4 + 1] = 30;
        colors[i * 4 + 2] = 30;
        colors[i * 4 + 3] = 100;
      } else {
        const t = Math.min(val / maxVal, 1);
        const rgb = viridisInterp(t);
        colors[i * 4]     = rgb[0];
        colors[i * 4 + 1] = rgb[1];
        colors[i * 4 + 2] = rgb[2];
        colors[i * 4 + 3] = 220;
      }
    }
  } else {
    // Expression mode but no gene loaded — show cell types dimmed
    for (let i = 0; i < N; i++) {
      const ct = cellData.celltype[i];
      const visible = celltypeVisible[ct] !== false;
      colors[i * 4]     = 80;
      colors[i * 4 + 1] = 80;
      colors[i * 4 + 2] = 80;
      colors[i * 4 + 3] = visible ? 80 : 0;
    }
  }
}

function viridisInterp(t) {
  const idx = t * (VIRIDIS.length - 1);
  const lo = Math.floor(idx);
  const hi = Math.min(lo + 1, VIRIDIS.length - 1);
  const f = idx - lo;
  return [
    Math.round(VIRIDIS[lo][0] * (1 - f) + VIRIDIS[hi][0] * f),
    Math.round(VIRIDIS[lo][1] * (1 - f) + VIRIDIS[hi][1] * f),
    Math.round(VIRIDIS[lo][2] * (1 - f) + VIRIDIS[hi][2] * f)
  ];
}

// ============================================================================
// deck.gl Initialization
// ============================================================================
function initDeck() {
  const bounds = metadata.bounds;
  const cx = (bounds.x_min + bounds.x_max) / 2;
  const cy = (bounds.y_min + bounds.y_max) / 2;
  const rangeX = bounds.x_max - bounds.x_min;
  const rangeY = bounds.y_max - bounds.y_min;
  const container = document.getElementById('deck-canvas');
  const zoom = Math.log2(Math.min(container.clientWidth / rangeX, container.clientHeight / rangeY)) - 0.5;

  deckgl = new deck.DeckGL({
    container: 'deck-canvas',
    views: new deck.OrthographicView(),
    initialViewState: {
      target: [cx, cy, 0],
      zoom: zoom,
      minZoom: -10,
      maxZoom: 10
    },
    controller: true,
    layers: createLayers(),
    getTooltip: getTooltipInfo,
    onViewStateChange: ({viewState}) => {
      updateHash(viewState);
    }
  });
}

function createLayers() {
  const N = cellData.x.length;
  const colorTrigger = [currentMode, currentGene, JSON.stringify(celltypeVisible), JSON.stringify(celltypeColors)];

  if (renderMode === 'polygons' && hasPolygons) {
    const layers = [
      new deck.SolidPolygonLayer({
        id: 'cell-polygons',
        data: polygonData,
        getPolygon: d => d.polygon,
        getFillColor: d => {
          const i = d.index;
          return [colors[i * 4], colors[i * 4 + 1], colors[i * 4 + 2], colors[i * 4 + 3]];
        },
        pickable: true,
        filled: true,
        updateTriggers: {
          getFillColor: colorTrigger
        },
        parameters: { depthTest: false }
      })
    ];

    // Add outline layer if outline width > 0
    if (polyOutlineWidth > 0) {
      layers.push(new deck.PathLayer({
        id: 'cell-outlines',
        data: polygonData,
        getPath: d => {
          const ring = d.polygon;
          // Close the ring if not already closed
          if (ring.length > 0) {
            const first = ring[0], last = ring[ring.length - 1];
            if (first[0] !== last[0] || first[1] !== last[1]) {
              return [...ring, ring[0]];
            }
          }
          return ring;
        },
        getColor: d => {
          const i = d.index;
          const a = colors[i * 4 + 3];
          return a > 0 ? [60, 60, 80, Math.min(a, 150)] : [0, 0, 0, 0];
        },
        getWidth: polyOutlineWidth,
        widthUnits: 'common',
        widthMinPixels: 0.3,
        widthMaxPixels: 3,
        pickable: false,
        updateTriggers: {
          getColor: colorTrigger,
          getWidth: [polyOutlineWidth]
        },
        parameters: { depthTest: false }
      }));
    }

    return layers;
  } else {
    return [new deck.ScatterplotLayer({
      id: 'cells',
      data: {length: N},
      getPosition: (_, {index}) => [positions[index * 3], positions[index * 3 + 1], 0],
      getFillColor: (_, {index}) => [colors[index * 4], colors[index * 4 + 1], colors[index * 4 + 2], colors[index * 4 + 3]],
      getRadius: pointRadius,
      radiusUnits: 'common',
      radiusMinPixels: 0.5,
      radiusMaxPixels: 20,
      pickable: true,
      updateTriggers: {
        getFillColor: colorTrigger,
        getRadius: [pointRadius]
      },
      parameters: { depthTest: false }
    })];
  }
}

function updateLayer() {
  rebuildColors();
  if (deckgl) {
    deckgl.setProps({ layers: createLayers() });
  }
}

// ============================================================================
// Render Mode Toggle (Points / Polygons)
// ============================================================================
function toggleRenderMode() {
  renderMode = renderMode === 'points' ? 'polygons' : 'points';
  const toggle = document.getElementById('poly-toggle');
  toggle.classList.toggle('active', renderMode === 'polygons');

  // Show/hide relevant sliders
  document.getElementById('point-size-row').style.display = renderMode === 'points' ? 'flex' : 'none';
  document.getElementById('poly-outline-row').style.display = renderMode === 'polygons' ? 'flex' : 'none';

  updateLayer();
}

function setPolyOutline(val) {
  polyOutlineWidth = Number(val);
  document.getElementById('poly-outline-val').textContent = val;
  updateLayer();
}

// ============================================================================
// Tooltip
// ============================================================================
function getTooltipInfo({index, object}) {
  // For polygon mode, object has .index; for point mode, use index directly
  let cellIdx;
  if (renderMode === 'polygons' && object) {
    cellIdx = object.index;
  } else {
    cellIdx = index;
  }
  if (cellIdx == null || cellIdx < 0 || !cellData) return null;

  const ct = cellData.celltype[cellIdx];
  if (celltypeVisible[ct] === false) return null;

  let html = `<div class="tt-label">Cell ID</div><div class="tt-value">${cellData.cell_id[cellIdx]}</div>`;
  html += `<div class="tt-label">Cell Type</div><div class="tt-value">${ct}</div>`;

  if (currentMode === 'expression' && currentGeneExpr) {
    const val = currentGeneExpr.dense[cellIdx];
    html += `<div class="tt-label">${currentGene}</div><div class="tt-value">${val.toFixed(3)}</div>`;
  }

  return { html, style: { backgroundColor: 'rgba(22,33,62,0.95)', color: '#e0e0e0', border: '1px solid #0f3460', borderRadius: '6px', padding: '8px 12px', fontSize: '12px' } };
}

// ============================================================================
// Cell Type UI
// ============================================================================
function buildCelltypeUI() {
  const listEl = document.getElementById('celltype-list');
  const listExprEl = document.getElementById('celltype-list-expr');
  listEl.innerHTML = '';
  listExprEl.innerHTML = '';

  // Count cells per type
  const counts = {};
  cellData.celltype.forEach(ct => { counts[ct] = (counts[ct] || 0) + 1; });

  metadata.cell_types.forEach(ct => {
    const row = createCelltypeRow(ct, counts[ct] || 0);
    listEl.appendChild(row);
    listExprEl.appendChild(row.cloneNode(true));
  });

  // Re-attach events for cloned nodes in expr list
  listExprEl.querySelectorAll('.ct-row').forEach(row => {
    const ct = row.dataset.celltype;
    row.querySelector('input[type="checkbox"]').addEventListener('change', (e) => {
      celltypeVisible[ct] = e.target.checked;
      syncCheckboxes(ct);
      updateLayer();
    });
    row.querySelector('input[type="color"]').addEventListener('input', (e) => {
      celltypeColors[ct] = hexToRgb(e.target.value);
      syncColorPickers(ct);
      saveColorPreferences();
      updateLayer();
    });
  });
}

function createCelltypeRow(ct, count) {
  const row = document.createElement('div');
  row.className = 'ct-row';
  row.dataset.celltype = ct;

  const cb = document.createElement('input');
  cb.type = 'checkbox';
  cb.checked = celltypeVisible[ct] !== false;
  cb.addEventListener('change', () => {
    celltypeVisible[ct] = cb.checked;
    syncCheckboxes(ct);
    updateLayer();
  });

  const cp = document.createElement('input');
  cp.type = 'color';
  cp.value = rgbToHex(celltypeColors[ct] || [128, 128, 128]);
  cp.addEventListener('input', () => {
    celltypeColors[ct] = hexToRgb(cp.value);
    syncColorPickers(ct);
    saveColorPreferences();
    updateLayer();
  });

  const label = document.createElement('span');
  label.className = 'ct-label';
  label.textContent = ct;
  label.title = ct;
  label.addEventListener('click', () => {
    cb.checked = !cb.checked;
    celltypeVisible[ct] = cb.checked;
    syncCheckboxes(ct);
    updateLayer();
  });

  const countEl = document.createElement('span');
  countEl.className = 'ct-count';
  countEl.textContent = count.toLocaleString();

  row.appendChild(cb);
  row.appendChild(cp);
  row.appendChild(label);
  row.appendChild(countEl);
  return row;
}

function syncCheckboxes(ct) {
  document.querySelectorAll(`.ct-row[data-celltype="${CSS.escape(ct)}"] input[type="checkbox"]`).forEach(cb => {
    cb.checked = celltypeVisible[ct] !== false;
  });
}

function syncColorPickers(ct) {
  const hex = rgbToHex(celltypeColors[ct] || [128, 128, 128]);
  document.querySelectorAll(`.ct-row[data-celltype="${CSS.escape(ct)}"] input[type="color"]`).forEach(cp => {
    cp.value = hex;
  });
}

function toggleAll(state) {
  metadata.cell_types.forEach(ct => { celltypeVisible[ct] = state; });
  document.querySelectorAll('.ct-row input[type="checkbox"]').forEach(cb => { cb.checked = state; });
  updateLayer();
}

// ============================================================================
// Mode Switch
// ============================================================================
function setMode(mode) {
  currentMode = mode;
  document.getElementById('mode-celltype').classList.toggle('active', mode === 'celltype');
  document.getElementById('mode-expression').classList.toggle('active', mode === 'expression');
  document.getElementById('celltype-section').style.display = mode === 'celltype' ? 'block' : 'none';
  document.getElementById('gene-section').style.display = mode === 'expression' ? 'block' : 'none';
  updateLayer();
  updateHash();
}

// ============================================================================
// Gene Search
// ============================================================================
function buildGeneSearch() {
  const input = document.getElementById('gene-search');
  const dropdown = document.getElementById('gene-dropdown');
  const geneNames = Object.keys(geneList).sort();
  let highlighted = -1;

  input.addEventListener('input', () => {
    const query = input.value.toLowerCase().trim();
    dropdown.innerHTML = '';
    highlighted = -1;

    if (query.length === 0) {
      dropdown.style.display = 'none';
      return;
    }

    // Prioritize: starts-with first, then contains
    const startsWith = geneNames.filter(g => g.toLowerCase().startsWith(query));
    const contains = geneNames.filter(g => !g.toLowerCase().startsWith(query) && g.toLowerCase().includes(query));
    const matches = [...startsWith, ...contains].slice(0, 50);

    if (matches.length === 0) {
      dropdown.style.display = 'none';
      return;
    }

    matches.forEach((gene, i) => {
      const opt = document.createElement('div');
      opt.className = 'gene-option';
      opt.textContent = gene;
      opt.addEventListener('click', () => loadGene(gene));
      opt.addEventListener('mouseenter', () => {
        highlighted = i;
        updateHighlight();
      });
      dropdown.appendChild(opt);
    });
    dropdown.style.display = 'block';
  });

  input.addEventListener('keydown', (e) => {
    const options = dropdown.querySelectorAll('.gene-option');
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      highlighted = Math.min(highlighted + 1, options.length - 1);
      updateHighlight();
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      highlighted = Math.max(highlighted - 1, 0);
      updateHighlight();
    } else if (e.key === 'Enter' && highlighted >= 0) {
      e.preventDefault();
      options[highlighted]?.click();
    } else if (e.key === 'Escape') {
      dropdown.style.display = 'none';
    }
  });

  function updateHighlight() {
    dropdown.querySelectorAll('.gene-option').forEach((opt, i) => {
      opt.classList.toggle('highlighted', i === highlighted);
      if (i === highlighted) opt.scrollIntoView({ block: 'nearest' });
    });
  }

  // Close dropdown on outside click
  document.addEventListener('click', (e) => {
    if (!e.target.closest('#gene-search') && !e.target.closest('#gene-dropdown')) {
      dropdown.style.display = 'none';
    }
  });
}

async function loadGene(geneName) {
  const filename = geneList[geneName];
  if (!filename) return;

  document.getElementById('gene-search').value = geneName;
  document.getElementById('gene-dropdown').style.display = 'none';

  // Show loading state
  document.getElementById('current-gene').innerHTML = `Loading <strong>${geneName}</strong>...`;

  try {
    const resp = await fetch(`data/genes/${filename}`);
    const sparse = await resp.json();

    // Expand sparse to dense
    const N = sparse.n;
    const dense = new Float32Array(N);
    let maxVal = 0;
    for (let j = 0; j < sparse.idx.length; j++) {
      dense[sparse.idx[j]] = sparse.val[j];
      if (sparse.val[j] > maxVal) maxVal = sparse.val[j];
    }

    // Use 99th percentile for color scale to avoid outlier compression
    const nonzero = sparse.val.slice().sort((a, b) => a - b);
    const p99idx = Math.floor(nonzero.length * 0.99);
    const p99 = nonzero[p99idx] || maxVal;

    currentGene = geneName;
    currentGeneExpr = { dense, maxVal: p99 };

    // Update UI
    document.getElementById('current-gene').innerHTML =
      `Showing: <strong>${geneName}</strong> <button id="clear-gene-btn" onclick="clearGene()">Clear</button>`;
    document.getElementById('expression-legend').style.display = 'block';
    document.getElementById('legend-min').textContent = '0';
    document.getElementById('legend-max').textContent = p99.toFixed(2);

    updateLayer();
    updateHash();
  } catch (err) {
    document.getElementById('current-gene').innerHTML = `<span style="color:#e94560">Error loading ${geneName}</span>`;
  }
}

function clearGene() {
  currentGene = null;
  currentGeneExpr = null;
  document.getElementById('gene-search').value = '';
  document.getElementById('current-gene').innerHTML = '';
  document.getElementById('expression-legend').style.display = 'none';
  updateLayer();
  updateHash();
}

// ============================================================================
// Point Size
// ============================================================================
function setPointSize(val) {
  pointRadius = Number(val);
  document.getElementById('point-size-val').textContent = val;
  updateLayer();
}

// ============================================================================
// Reset View
// ============================================================================
function resetView() {
  if (!deckgl || !metadata) return;
  const bounds = metadata.bounds;
  const cx = (bounds.x_min + bounds.x_max) / 2;
  const cy = (bounds.y_min + bounds.y_max) / 2;
  const container = document.getElementById('deck-canvas');
  const rangeX = bounds.x_max - bounds.x_min;
  const rangeY = bounds.y_max - bounds.y_min;
  const zoom = Math.log2(Math.min(container.clientWidth / rangeX, container.clientHeight / rangeY)) - 0.5;

  deckgl.setProps({
    initialViewState: {
      target: [cx, cy, 0],
      zoom: zoom,
      minZoom: -10,
      maxZoom: 10,
      transitionDuration: 500
    }
  });
}

// ============================================================================
// Screenshot
// ============================================================================
function takeScreenshot() {
  const canvas = document.querySelector('#deck-canvas canvas');
  if (!canvas) return;
  const link = document.createElement('a');
  link.download = `${metadata.dataset_name.replace(/\s+/g, '_')}_screenshot.png`;
  link.href = canvas.toDataURL('image/png');
  link.click();
}

// ============================================================================
// URL Hash for sharing views
// ============================================================================
function updateHash(viewState) {
  const params = new URLSearchParams();
  if (viewState) {
    params.set('x', Math.round(viewState.target[0]));
    params.set('y', Math.round(viewState.target[1]));
    params.set('z', viewState.zoom.toFixed(2));
  }
  if (currentMode !== 'celltype') params.set('mode', currentMode);
  if (currentGene) params.set('gene', currentGene);
  if (renderMode !== 'points') params.set('render', renderMode);
  const hash = params.toString();
  if (hash) history.replaceState(null, '', '#' + hash);
}

function restoreFromHash() {
  const hash = window.location.hash.slice(1);
  if (!hash) return;
  const params = new URLSearchParams(hash);

  if (params.get('render') === 'polygons' && hasPolygons) {
    toggleRenderMode();
  }
  if (params.has('mode')) setMode(params.get('mode'));
  if (params.has('gene')) {
    setMode('expression');
    loadGene(params.get('gene'));
  }

  if (params.has('x') && params.has('y') && params.has('z')) {
    const target = [Number(params.get('x')), Number(params.get('y')), 0];
    const zoom = Number(params.get('z'));
    deckgl.setProps({
      initialViewState: { target, zoom, minZoom: -10, maxZoom: 10 }
    });
  }
}

// ============================================================================
// Color Utilities
// ============================================================================
function rgbToHex(rgb) {
  return '#' + rgb.map(c => c.toString(16).padStart(2, '0')).join('');
}

function hexToRgb(hex) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return [r, g, b];
}

// ============================================================================
// Start
// ============================================================================
init().catch(err => {
  document.getElementById('loading-text').textContent = 'Error: ' + err.message;
  console.error(err);
});
</script>
</body>
</html>
